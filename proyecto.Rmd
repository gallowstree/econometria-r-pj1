---
title: "Proyecto HousePrices :P"
output: html_notebook
---

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(cleandata)
library(corrplot)
library(gridExtra)

```

```{r}
all_data=read.csv("train.csv")
all_data$ocean_proximity<-as.factor(all_data$ocean_proximity)
all_data$median_house_value<-all_data$median_house_value / 10000
all_data
```

Usamos summary para ver cuáles columnas tienen NAs y verificamos el valor mínimo de cada columna para asegurarnos que no hay NAs disfrazados de 0

```{r fig.width=12}
summary(all_data)
```

Solamente total_bedrooms tiene faltantes y son 144, veamos cuánto es eso en porcentaje.

```{r}
naCount<-sum(is.na(all_data$total_bedrooms))

naCount / length(all_data$total_bedrooms) * 100
```

Prácticamente 1% de datos faltantes. Más adelante nos ocuparemos de ellos. Por ahora realizaremos algo de análisis exploratorio y codificación.

```{r}
all_data %>% 
  group_by(ocean_proximity) %>%
  summarize(mean_value = mean(median_house_value)) %>%
  arrange(desc(mean_value))
```

Es bastante claro que al menos en cierta medida, la proximidad al océano afecta el precio. Esto nos da una pista de que podemos codificar esta variable como ordinal.

```{r}
op_order<-c("INLAND", "<1H OCEAN", "NEAR OCEAN","NEAR BAY", "ISLAND")
all_data$enc_ocean_proximity<-encode_ordinal(all_data[,11, drop=FALSE], order=op_order, out.int=T)
```

```{r}
nasRemoved<-all_data %>% 
  select(-c(ocean_proximity, id)) %>%
  filter(!is.na(total_bedrooms))
         
corrplot(cor(nasRemoved), 
         method = "ellipse", 
         type="full",
        addCoef.col = rgb(0,0,0, alpha = 0.6), diag = TRUE, number.cex=0.77, 
        col= colorRampPalette(c("red","white", "green"))(100))
```

Vemos que nuestra variable con NAs (total_bedrooms) tiene correlación casi perfecta con households, por lo que usaremos el valor de esta para obtener datos de imputación. 
```{r}
print(summary(all_data$total_bedrooms))

total_bedroom_imputer<-lm(nasRemoved$total_bedrooms ~ nasRemoved$households)
print(summary(total_bedroom_imputer))

all_data$total_bedrooms<-ifelse(is.na(all_data$total_bedrooms), 
                                predict(total_bedroom_imputer, data.frame(all_data$households)), 
                                all_data$total_bedrooms)

print(summary(all_data$total_bedrooms))
```



Posiblemente será útil más adelante tener features obtenidas aplicando binning a ciertas variables.

```{r fig.height=4, fig.width=12.5}
plot_outliers<-function(df, colname) {
  column<-sym(colname)

  hist<-ggplot(df, aes(x=unlist(!!column)))+
    geom_histogram(color="white", fill="blue")+
    theme_minimal()
  
  box<-ggplot(df, aes(x=unlist(!!column)))+
    geom_boxplot()+
    theme_minimal()
  
  
  qq<-ggplot(df, aes(sample=!!column))+
    stat_qq()+
    stat_qq_line(col="red", lwd=1)
    theme_minimal()

  grid.arrange(hist, box, qq, ncol=3)
}

for (col in names(nasRemoved)) {
  plot_outliers(nasRemoved, col)
}

```
TODOS: dividir en bins
- housing age -> 5 o 10 años
- lat y long
- qué pasa con total rooms? comparemos con rooms/household y otros ratios. Igual con bedrooms
- pop tmaibén tiene muchos outliers... pop/households

Feature ideas:
- median income per capita
- 

```{r}

all_data$age_binned_5<-cut(all_data$housing_median_age, breaks = c(0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55), labels = F)
#summary(all_data$age_binned_5)

all_data$age_binned_10<-cut(all_data$housing_median_age, breaks = c(0, 10, 20, 30, 40, 50, 60), labels = F)

cols<-all_data %>% select(age_binned_5, age_binned_10, median_house_value)
corrplot( cor(cols),
  method = "ellipse", 
         type="full",
        addCoef.col = rgb(0,0,0, alpha = 0.6), diag = TRUE, number.cex=0.77, 
        col= colorRampPalette(c("red","white", "green"))(100))
```

