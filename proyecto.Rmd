---
title: "Proyecto HousePrices :P"
output: html_notebook
---
# Librerías
```{r message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(cleandata)
library(corrplot)
library(gridExtra)
library(Metrics)
library(caret)
library(MASS)
library(robustbase)
library(cvTools)
library(sp)
library(rgdal)
library(geosphere)
library(dismo)
library(rgeos)
library(RANN)
```

# Pre-procesamiento, limpieza y análisis inicial
```{r}

median_house_value_scale = 100000

initialPreprocessing<-function(df) {
  df$ocean_proximity<-as.factor(df$ocean_proximity)
  
  op_order<-c("INLAND", "<1H OCEAN", "NEAR OCEAN","NEAR BAY", "ISLAND")
  enc_ocean_proximity<-encode_ordinal(data.frame(enc_ocean_proximity=df[["ocean_proximity"]]), order=op_order, out.int=T, full_print = F)
  df<-cbind(df, enc_ocean_proximity=enc_ocean_proximity)
  
  if("median_house_value" %in% colnames(df)) {
      df$median_house_value<-df$median_house_value / median_house_value_scale
  }
  
  return(df)
}

loadAndPreprocess<-function(csvName) {
  return(initialPreprocessing(read.csv(csvName)))
}

all_data=loadAndPreprocess("train.csv")
all_data
```

Es bastante claro que al menos en cierta medida, la proximidad al océano afecta el precio. Esto nos da una pista de que podemos codificar esta variable como ordinal. Movimos esto a nuestra función de pre-procesamiento arriba para aprovecharlo en cualquier dataset.
```{r eval=FALSE}
all_data %>% 
  group_by(ocean_proximity) %>%
  summarize(mean_value = mean(median_house_value)) %>%
  arrange(desc(mean_value))
```


Usamos summary para ver cuáles columnas tienen NAs y verificamos el valor mínimo de cada columna para asegurarnos que no hay NAs disfrazados de 0

```{r fig.width=12}
summary(all_data)
```

Solamente total_bedrooms tiene faltantes y son 144, veamos cuánto es eso en porcentaje.

```{r}
naCount<-sum(is.na(all_data$total_bedrooms))

naCount / length(all_data$total_bedrooms) * 100
```

Prácticamente 1% de datos faltantes. Nos ocuparemos de ellos, pero antes debemos divir los datos en train/test
```{r}
set.seed(279720)
spec = c(train = .80, validate = .20)
#spec = c(train = .7, test = .15, validate = .15)

g = sample(cut(
  seq(nrow(all_data)), 
  nrow(all_data)*cumsum(c(0,spec)),
  labels = names(spec)
))

data = split(all_data, g)
```


```{r}
nasRemoved<-data$train %>% 
  dplyr::select(-c(ocean_proximity, id)) %>%
  filter(!is.na(total_bedrooms))
         
corrplot(cor(nasRemoved), 
         method = "ellipse", 
         type="full",
        addCoef.col = rgb(0,0,0, alpha = 0.6), diag = TRUE, number.cex=0.77, 
        col= colorRampPalette(c("red","white", "green"))(100))
```

# Imputación
Vemos que nuestra variable con NAs (total_bedrooms) tiene correlación casi perfecta con households, por lo que usaremos el valor de esta para obtener datos de imputación. 

```{r}

imp_total_bedrooms<-function(df, traindata=nasRemoved) {
  x<-traindata$households
  y<-traindata$total_bedrooms
  lr<-lm(y ~ x)
  new<-data.frame(x = df$households)
  
  df$total_bedrooms<-as.integer(ifelse(is.na(df$total_bedrooms), 
                                predict(lr, new), 
                                df$total_bedrooms))
  
  return(df)
}

data$train<-imp_total_bedrooms(data$train)
data$validate<-imp_total_bedrooms(data$validate)

print(summary(data$train$total_bedrooms))
print(summary(data$validate$total_bedrooms))

```



# Outliers pt.1
```{r fig.height=4, fig.width=12.5}
plot_outliers<-function(df, colname) {
  column<-sym(colname)

  hist<-ggplot(df, aes(x=!!column))+
    geom_histogram(color="white", fill="blue")+
    theme_minimal()
  
  box<-ggplot(df, aes(x=!!column))+
    geom_boxplot()+
    theme_minimal()
  
  
  qq<-ggplot(df, aes(sample=!!column))+
    stat_qq()+
    stat_qq_line(col="red", lwd=1)
    theme_minimal()

  grid.arrange(hist, box, qq, ncol=3)
}
```


```{r fig.height=4, fig.width=12.5}
plotAllOutliers<-function(data) {
  filtered<-data
  if("id" %in% colnames(data)) {
    filtered<-data %>% 
        dplyr::select(-c(ocean_proximity, id)) %>%
        filter(!is.na(total_bedrooms))
  }
  for (col in names(filtered)) {
     plot_outliers(filtered, col)
  }
}

```

```{r fig.height=4, fig.width=12.5}
plotAllOutliers(data$train)
```

# Creación y análisis de nuevos features

```{r eval=FALSE, fig.width=7.5, }
beds_per_rooms<-data$train$total_bedrooms / data$train$total_rooms
rooms_per_household<-data$train$total_rooms / data$train$households
income_per_capita<-data$train$median_income/data$train$population
income_per_household<-data$train$median_income/data$train$households
beds_per_capita<-data$train$total_bedrooms / data$train$population
rooms_per_capita<-data$train$total_rooms / data$train$population
pop_per_household<-data$train$population/data$train$households # check this one agian after doing something with the outliers
pop_per_bedroom<-data$train$population/data$train$total_bedrooms
pop_per_room<-data$train$population/data$train$total_rooms

candidates<-data.frame(beds_per_rooms, rooms_per_household, income_per_capita, income_per_household, beds_per_capita, rooms_per_capita, pop_per_household, pop_per_bedroom, pop_per_room, data$train$median_house_value)

summary(candidates)
corrplot(cor(candidates), 
         method = "ellipse", 
         type="full",
        addCoef.col = rgb(0,0,0, alpha = 0.6), diag = TRUE, number.cex=0.7,  tl.cex=0.75 , 
        col= colorRampPalette(c("red","white", "green"))(100))
```


```{r}

addExtraFeats<-function(df) {
  if("beds_per_rooms" %in% colnames(df)) { 
    return(df)
  }
  
  beds_per_rooms<-df$total_bedrooms / df$total_rooms
  rooms_per_household<-df$total_rooms / df$households
  income_per_capita<-df$median_income/df$population
  income_per_household<-df$median_income/df$households
  beds_per_capita<-df$total_bedrooms / df$population
  rooms_per_capita<-df$total_rooms / df$population
  pop_per_household<-df$population/df$households  
  
  return(cbind(df, beds_per_rooms, rooms_per_capita, rooms_per_household, income_per_capita))
}

```

```{r}
data$train<-addExtraFeats(data$train)
data$validate<-addExtraFeats(data$validate)
```

# Entrenamiento de modelo pt.1

```{r}
model_rmse<-function(model, observations, actual_values, scale=median_house_value_scale) {
  predictions<-predict(model, observations)
  return(rmse(predictions, actual_values)*scale)
}

scores<-function(model, xs=data$validate, y=data$validate$median_house_value, cost = rmspe, ...) {
  folds <- cvFolds(nrow(xs), K = 5, R = 10)
  return(data.frame(
    validation_error=model_rmse(model, xs, y),
    k_fold_cv_error=repCV(model, cost = cost, folds = folds, ...)$cv[[1]]*median_house_value_scale
  ))
}
```

```{r}
extractTrainingVars<-function(data) {
  return(data %>% dplyr::select(median_house_value, 
                median_income,
                enc_ocean_proximity,
                total_rooms,
                latitude,
                longitude,
                total_bedrooms,
                housing_median_age,
                beds_per_rooms,
                rooms_per_capita,
                rooms_per_household,
                population,
                income_per_capita))
}

training_vars_1<-extractTrainingVars(data$train)

fit1<-lm(median_house_value ~ ., data = training_vars_1)
scores(fit1)

```


# Outliers pt.2
## plots
```{r eval=FALSE}
outlier_values <- boxplot.stats(data$train$total_rooms)$out  # outlier values.
boxplot(data$train$total_rooms, main="total_rooms", boxwex=0.1)
print(outlier_values)

outlier_values <- boxplot.stats(data$train$total_bedrooms)$out  # outlier values.
boxplot(data$train$total_bedrooms, main="total_bedrooms", boxwex=0.1)
print(outlier_values)

outlier_values <- boxplot.stats(data$train$population)$out  # outlier values.
boxplot(data$train$population, main="population", boxwex=0.1)
print(outlier_values)

outlier_values <- boxplot.stats(data$train$households)$out  # outlier values.
boxplot(data$train$households, main="households", boxwex=0.1)
print(outlier_values)

outlier_values <- boxplot.stats(data$train$median_income)$out  # outlier values.
boxplot(data$train$median_income, main="median_income", boxwex=0.1)
print(outlier_values)

outlier_values <- boxplot.stats(data$train$median_house_value)$out  # outlier values.
boxplot(data$train$median_house_value, main="median_house_value", boxwex=0.1)
print(outlier_values)
```

## Cook's distance
```{r fig.height=5, fig.width=6}
cooksd<-cooks.distance(fit1)
plot(cooksd, pch="*", cex=1, main="Influential Obs by Cooks distance")  # plot cook's distance
abline(h = 4*mean(cooksd, na.rm=T), col="red")  # add cutoff line
text(x=1:length(cooksd)+1, y=cooksd, labels=ifelse(cooksd>4*mean(cooksd, na.rm=T),names(cooksd),""), col="red")  # add labels
```
## Eliminación de los peores outliers

```{r}
distances<-data.frame(d=cooksd[cooksd>4*mean(cooksd, na.rm=T)])
distances<-distances %>% arrange(desc(d))
indices<-as.integer(row.names(distances))

removeTopNOutliers<-function(n, indices, data) {
  return( data[-match(indices[1:n], rownames(data)), ])
}

trainMinusTopOL<-removeTopNOutliers(3, indices, data$train)
trainMinusAllOL<-removeTopNOutliers(length(indices), indices, data$train)
fitTop3  <-lm(median_house_value ~ ., data = extractTrainingVars(trainMinusTopOL))
fitAll<-lm(median_house_value ~ ., data = extractTrainingVars(trainMinusAllOL))
scores(fitTop3  )
scores(fitAll)

data$train[match(indices[1:3], rownames(data$train)),]
summary(fitTop3)
summary(fitAll)
```
## Outliers test
```{r}
outlierIndices<-as.numeric(names(car::outlierTest(fit1)[[1]]))
trainMinusAllOL2<-removeTopNOutliers(length(outlierIndices), outlierIndices, data$train)
fitAll2<-lm(median_house_value ~ ., data = extractTrainingVars(trainMinusAllOL2))
scores(fitAll2)
```
## Capping
```{r}
cap<-function(x, IQR_factor=1.5, qntLo=.25, qntHi=.75, capLo=.05, capHi=.95) {
  qnt <- quantile(x, probs=c(qntLo, qntHi), na.rm=T)
  caps <- quantile(x, probs=c(capLo, capHi), na.rm=T)
  delta<-IQR_factor * IQR(x, na.rm=T)
  thresholds<-c(qnt[1] - delta, qnt[2] + delta)
  x[x < thresholds[1]] <- caps[1]
  x[x > thresholds[2]] <- caps[2]
  print(paste("caps:", caps[1], caps[2]))
  print(paste("thresholds:", thresholds[1], thresholds[2]))

  return(x)
}

extractAndRecalculateTrainingVars<-function(data) {
  beds_per_rooms<-data$total_bedrooms / data$total_rooms
  rooms_per_household<-data$total_rooms / data$households
  income_per_capita<-data$median_income/data$population
  income_per_household<-data$median_income/data$households
  beds_per_capita<-data$total_bedrooms / data$population
  rooms_per_capita<-data$total_rooms / data$population
  pop_per_household<-data$population/data$households  
  
  return(data.frame(median_house_value=data$median_house_value,
                median_income=data$median_income,
                enc_ocean_proximity=data$enc_ocean_proximity,
                total_rooms=data$total_rooms,
                latitude=data$latitude,
                longitude=data$longitude,
                total_bedrooms=data$total_bedrooms,
                housing_median_age=data$housing_median_age,
                beds_per_rooms=beds_per_rooms,
                rooms_per_capita=rooms_per_capita,
                rooms_per_household=rooms_per_household,
                income_per_capita=income_per_capita))
}

compare_capped_performance<-function(train_data, colName, candidates, extract=extractAndRecalculateTrainingVars) {
  for (candidate in names(candidates)) {
    print(candidate)
    
    train_data[[colName]]<-candidates[[candidate]]

    fit<-lm(median_house_value ~ ., data = extract(train_data))
    print(paste(scores(fit)))
  }
}

data_train<-trainMinusTopOL
```

```{r fig.height=4, fig.width=12.5}
candidates<-data.frame(
  original=data_train$total_rooms,
  cap_default=cap(data_train$total_rooms)
  ,cap_5=cap(data_train$total_rooms, IQR_factor = 19)


)

plotAllOutliers(candidates)
compare_capped_performance(data_train, "total_rooms", candidates)
```

```{r fig.height=4, fig.width=12.5}
candidates<-data.frame(
  original=data_train$total_bedrooms,
  cap_default=cap(data_train$total_bedrooms)
    ,cap_2=cap(data_train$total_bedrooms, IQR_factor = 1.5)
  ,cap_3=cap(data_train$total_bedrooms, IQR_factor = 2)
  ,cap_5=cap(data_train$total_bedrooms, IQR_factor = 7)
  ,cap_5=cap(data_train$total_bedrooms, IQR_factor = 16)


)

plotAllOutliers(candidates)
compare_capped_performance(data_train, "total_bedrooms", candidates)
```

```{r fig.height=4, fig.width=12.5}
candidates<-data.frame(
  original=data_train$population,
  cap_default=cap(data_train$population)
  ,cap_6=cap(data_train$population, IQR_factor = 18)


)

plotAllOutliers(candidates)
compare_capped_performance(data_train, "population", candidates)

```

```{r fig.height=4, fig.width=12.5}
candidates<-data.frame(
  original=data_train$households,
  cap_default=cap(data_train$households)
  ,cap_2=cap(data_train$households, IQR_factor = 1.5)
  ,cap_6=cap(data_train$households, IQR_factor = 17.5)

)

plotAllOutliers(candidates)
compare_capped_performance(data_train, "households", candidates)


```

```{r}
candidates<-data.frame(
  original=data_train$median_income,
  cap_default=cap(data_train$median_income)
  ,cap_2=cap(data_train$median_income, IQR_factor = 1.5)
  ,cap_3=cap(data_train$median_income, IQR_factor = 2) ##DING!
)

#plotAllOutliers(candidates)
compare_capped_performance(data_train, "median_income", candidates, extract = extractTrainingVars)
compare_capped_performance(data_train, "median_income", candidates)


prueba<-data_train
prueba[["median_income"]]<-candidates$cap_3

fit_cap<-lm(median_house_value ~ ., data = extractAndRecalculateTrainingVars(prueba))
scores(fit_cap)
```


# Transformaciones y escalado
```{r}
preProcess1<-preProcess(subset(data_train, select=-c(median_house_value, latitude, longitude, id)))
train1<-predict(preProcess1, data_train)
validate1<-predict(preProcess1, data$validate)
```


```{r}

fitpp2<-lm(median_house_value ~ median_income+poly(median_income, 2) +
                                latitude * longitude +
                                enc_ocean_proximity +
                                population+poly(population, 2)+
                                total_rooms*total_bedrooms+
                                total_bedrooms+poly(total_bedrooms, 3)+
                                housing_median_age+poly(housing_median_age, 3)+
                                beds_per_rooms+poly(beds_per_rooms, 3)+
                                rooms_per_capita+
                                rooms_per_household+poly(rooms_per_household, 3)+
                                income_per_capita
                                , data = extractTrainingVars(train1))

summary(fitpp2)
scores(fitpp2, xs=validate1, y=validate1$median_house_value)

```
66204.42	64151.6
66085.98	64009.12	
65934.67	64135.29		
65891.08	64631.93	
65805.51	64390.26		
65794.3	64320.67	
65786.1	64297.81

```{r}
full_threeway_model = lm(median_house_value ~ (.)^3, data = extractTrainingVars(train1))
summary(full_threeway_model)
scores(full_threeway_model, xs=validate1, y=validate1$median_house_value)

```



# Entrenamiento de modelos robustos (tolerantes a outliers)
## MM-type regression
```{r eval=FALSE}

fitLmrob<-lmrob(median_house_value ~ median_income+poly(median_income, 2) +
                                latitude * longitude +
                                enc_ocean_proximity +
                                population+poly(population, 2)+
                                total_rooms*total_bedrooms+
                                total_bedrooms+poly(total_bedrooms, 3)+
                                housing_median_age+poly(housing_median_age, 3)+
                                beds_per_rooms+poly(beds_per_rooms, 3)+
                                rooms_per_capita+
                                rooms_per_household+poly(rooms_per_household, 3)+
                                income_per_capita
                                , data = extractTrainingVars(train1))

summary(fitLmrob)
scores(fitLmrob, xs=validate1, y=validate1$median_house_value, cost=rtmspe, trim=0.1)

```


## LTS robust regression
```{r eval=FALSE}
fitLts<-ltsReg(median_house_value ~ median_income+poly(median_income, 2) +
                                latitude * longitude +
                                enc_ocean_proximity +
                                population+poly(population, 2)+
                                total_rooms*total_bedrooms+
                                total_bedrooms+poly(total_bedrooms, 3)+
                                housing_median_age+poly(housing_median_age, 3)+
                                beds_per_rooms+poly(beds_per_rooms, 3)+
                                rooms_per_capita+
                                rooms_per_household+poly(rooms_per_household, 3)+
                                income_per_capita
                                , data = extractTrainingVars(train1))
print("fitted")
scores(fitLts, cost=rtmspe, trim=0.1)
```

```{r eval=FALSE}
irls<-rlm(median_house_value ~ median_income+poly(median_income, 2) +
                                latitude * longitude +
                                enc_ocean_proximity +
                                population+poly(population, 2)+
                                total_rooms*total_bedrooms+
                                total_bedrooms+poly(total_bedrooms, 3)+
                                housing_median_age+poly(housing_median_age, 3)+
                                beds_per_rooms+poly(beds_per_rooms, 3)+
                                rooms_per_capita+
                                rooms_per_household+poly(rooms_per_household, 3)+
                                income_per_capita
                                , data = extractTrainingVars(train1))
irls_bi<-rlm(median_house_value ~median_income+poly(median_income, 2) +
                                latitude * longitude +
                                enc_ocean_proximity +
                                population+poly(population, 2)+
                                total_rooms*total_bedrooms+
                                total_bedrooms+poly(total_bedrooms, 3)+
                                housing_median_age+poly(housing_median_age, 3)+
                                beds_per_rooms+poly(beds_per_rooms, 3)+
                                rooms_per_capita+
                                rooms_per_household+poly(rooms_per_household, 3)+
                                income_per_capita
                                , data = extractTrainingVars(train1), psi = psi.bisquare)
summary(irls)
summary(irls_bi)
```

```{r eval=FALSE}
scores(irls, xs=validate1, y=validate1$median_house_value)
scores(irls_bi,  xs=validate1, y=validate1$median_house_value)
```
 
# Predicciones en test-set

```{r}
timestamp<-function() {
  my_options <- options(digits.secs = 3)
  timestamp<-strftime(Sys.time(), "%m%d_%H%M%OS")
  options(my_options)  
  return(timestamp)
}

writePredictions<-function(predictions, name, ids=testing_set$id) {
  data<-cbind(id=ids, median_house_value=abs(predictions*median_house_value_scale))
  filename<-paste("predictions/", timestamp(), "_", name, ".csv", sep="")
  write.csv(data, filename, row.names = FALSE, quote=FALSE)
}

writePredictions1<-function(model, name, test_set=testing_set) {
  writePredictions(predict(model, test_set), name)
}
```

```{r}
testing_set<-loadAndPreprocess("test.csv")
testing_set<-imp_total_bedrooms(testing_set)
testing_set<-addExtraFeats(testing_set)
testing_set<-predict(preProcess1, testing_set)
```

```{r}
#writePredictions1(fitLmrob, "fitLmrob")
#writePredictions1(fitLts, "fitLts")
#writePredictions1(irls, "irls")
writePredictions1(full_threeway_model, "full_threeway_model")
```
# Clustering 

## Cálculo de matriz de distancias
```{r eval=FALSE}
x <- train1$longitude
y <- train1$latitude

xy <- SpatialPointsDataFrame(
      matrix(c(x,y), ncol=2), data.frame(ID=train1$id),
      proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84"))

mdist <- distm(xy)
```

## Dividir training set en clusters
```{r}
hc <- hclust(as.dist(mdist), method="complete")

d=40000 # radio en metros

xy$clust <- cutree(hc, h=d)
train1$clust <- factor(xy$clust)
```

## Calcular el centroide de cada cluster
```{r}
cent <- matrix(ncol=2, nrow=max(xy$clust))
for (i in 1:max(xy$clust))
    cent[i,] <- gCentroid(subset(xy, clust == i))@coords
```

## Visualización
```{r fig.width=10, fig.height=10}

xy@bbox[] <- as.matrix(extend(extent(xy),0.001))

ci <- circles(cent, d=d, lonlat=T)

plot(ci@polygons, axes=T)
plot(xy, col=rainbow(max(xy$clust))[factor(xy$clust)], add=T)
as.data.frame(table(xy$clust))
```

```{r}
points<-data.frame(x=validate1$longitude, y=validate1$latitude)
validate1$clust<-factor(nn2(as.data.frame(cent), query=points,k=1)$nn.idx)
```

```{r}
points<-data.frame(x=testing_set$longitude, y=testing_set$latitude)
testing_set$clust<-factor(nn2(as.data.frame(cent), query=points,k=1)$nn.idx)
```




```{r}

OHE_clust<-function(df) {
  col<-df %>% dplyr::select(clust)
  encoder<-dummyVars("~.", data=col, x=factor(1:240))
  cols<-data.frame(predict(encoder, newdata = col))
  return(cbind(df, cols))
}

trainClust<-OHE_clust(train1)
validateClust<-OHE_clust(validate1)
testing_setClust<-OHE_clust(testing_set)


```

```{r}
fillMissingDummyVars<-function(df) {
  for (n in setdiff(levels(train1$clust), levels(df$clust))) {
    df[[paste("clust", n, sep=".")]]<-0
  }
  return(df)
}
validateClust<-fillMissingDummyVars(validateClust)
testing_setClust<-fillMissingDummyVars(testing_setClust)
```

```{r}
extractTrainingVarsClust<-function(data) {
  return(data %>% dplyr::select(median_house_value, 
                median_income,
                enc_ocean_proximity,
                total_rooms,
                latitude,
                longitude,
                total_bedrooms,
                housing_median_age,
                beds_per_rooms,
                rooms_per_capita,
                rooms_per_household,
                population,
                income_per_capita, starts_with("clust.")))
}

```

```{r}
fitClust<-lm(median_house_value ~ median_income+poly(median_income, 2) +
                                latitude * longitude +
                                enc_ocean_proximity +
                                population+poly(population, 2)+
                                total_rooms*total_bedrooms+
                                total_bedrooms+poly(total_bedrooms, 3)+
                                housing_median_age+poly(housing_median_age, 3)+
                                beds_per_rooms+poly(beds_per_rooms, 3)+
                                rooms_per_capita+
                                rooms_per_household+poly(rooms_per_household, 3)+
                                income_per_capita + .
                                , data = extractTrainingVarsClust(trainClust))

summary(fitClust)
scores(fitClust, xs=validateClust, y=validateClust$median_house_value)

```
```{r}
writePredictions1(fitClust, "fitClust40km", test_set=testing_setClust)

```


