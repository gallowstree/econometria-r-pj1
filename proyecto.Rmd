---
title: "Proyecto HousePrices :P"
output: html_notebook
---

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(cleandata)
library(corrplot)
library(gridExtra)

```

# Pre-procesamiento, limpieza y análisis inicial
```{r}

initialPreprocessing<-function(df) {
  median_house_value_scale = 10000
  df$ocean_proximity<-as.factor(df$ocean_proximity)
  df$median_house_value<-df$median_house_value / median_house_value_scale
  
  op_order<-c("INLAND", "<1H OCEAN", "NEAR OCEAN","NEAR BAY", "ISLAND")
  enc_ocean_proximity<-encode_ordinal(data.frame(df[["ocean_proximity"]]), order=op_order, out.int=T)
  df<-cbind(df, enc_ocean_proximity)
  return(df)
}

loadAndPreprocess<-function(csvName) {
  return(initialPreprocessing(read.csv(csvName)))
}

all_data=loadAndPreprocess("train.csv")
all_data
```

Es bastante claro que al menos en cierta medida, la proximidad al océano afecta el precio. Esto nos da una pista de que podemos codificar esta variable como ordinal. Movimos esto a nuestra función de pre-procesamiento arriba para aprovecharlo en cualquier dataset.
```{r}
all_data %>% 
  group_by(ocean_proximity) %>%
  summarize(mean_value = mean(median_house_value)) %>%
  arrange(desc(mean_value))
```


Usamos summary para ver cuáles columnas tienen NAs y verificamos el valor mínimo de cada columna para asegurarnos que no hay NAs disfrazados de 0

```{r fig.width=12}
summary(all_data)
```

Solamente total_bedrooms tiene faltantes y son 144, veamos cuánto es eso en porcentaje.

```{r}
naCount<-sum(is.na(all_data$total_bedrooms))

naCount / length(all_data$total_bedrooms) * 100
```

Prácticamente 1% de datos faltantes. Nos ocuparemos de ellos, pero antes debemos divir los datos en train/test
```{r}
set.seed(279720)
spec = c(train = .7, test = .15, validate = .15)

g = sample(cut(
  seq(nrow(all_data)), 
  nrow(all_data)*cumsum(c(0,spec)),
  labels = names(spec)
))

data = split(all_data, g)
```


```{r}
nasRemoved<-data$train %>% 
  select(-c(ocean_proximity, id)) %>%
  filter(!is.na(total_bedrooms))
         
corrplot(cor(nasRemoved), 
         method = "ellipse", 
         type="full",
        addCoef.col = rgb(0,0,0, alpha = 0.6), diag = TRUE, number.cex=0.77, 
        col= colorRampPalette(c("red","white", "green"))(100))
```

Vemos que nuestra variable con NAs (total_bedrooms) tiene correlación casi perfecta con households, por lo que usaremos el valor de esta para obtener datos de imputación. 

```{r}

imp_total_bedrooms<-function(df, traindata=nasRemoved) {
  x<-traindata$households
  y<-traindata$total_bedrooms
  lr<-lm(y ~ x)
  new<-data.frame(x = df$households)
  
  df$total_bedrooms<-as.integer(ifelse(is.na(df$total_bedrooms), 
                                predict(lr, new), 
                                df$total_bedrooms))
  
  return(df)
}

data$train<-imp_total_bedrooms(data$train)
data$test<-imp_total_bedrooms(data$test)
data$validate<-imp_total_bedrooms(data$validate)

print(summary(data$train$total_bedrooms))
print(summary(data$test$total_bedrooms))
print(summary(data$validate$total_bedrooms))

```




```{r fig.height=4, fig.width=12.5}
plot_outliers<-function(df, colname) {
  column<-sym(colname)

  hist<-ggplot(df, aes(x=unlist(!!column)))+
    geom_histogram(color="white", fill="blue")+
    theme_minimal()
  
  box<-ggplot(df, aes(x=unlist(!!column)))+
    geom_boxplot()+
    theme_minimal()
  
  
  qq<-ggplot(df, aes(sample=!!column))+
    stat_qq()+
    stat_qq_line(col="red", lwd=1)
    theme_minimal()

  grid.arrange(hist, box, qq, ncol=3)
}

for (col in names(nasRemoved)) {
  plot_outliers(nasRemoved, col)
}

```
