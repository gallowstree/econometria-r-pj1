---
title: "Proyecto HousePrices :P"
output: html_notebook
---

```{r message=FALSE, warning=FALSE}
library(dplyr)
library(ggplot2)
library(cleandata)
library(corrplot)
library(gridExtra)
library(Metrics)
library(caret)
library(MASS)
library(robustbase)
library(cvTools)

```

# Pre-procesamiento, limpieza y análisis inicial
```{r}

median_house_value_scale = 10000

initialPreprocessing<-function(df) {
  df$ocean_proximity<-as.factor(df$ocean_proximity)
  
  op_order<-c("INLAND", "<1H OCEAN", "NEAR OCEAN","NEAR BAY", "ISLAND")
  enc_ocean_proximity<-encode_ordinal(data.frame(enc_ocean_proximity=df[["ocean_proximity"]]), order=op_order, out.int=T)
  df<-cbind(df, enc_ocean_proximity=enc_ocean_proximity)
  
  if("median_house_value" %in% colnames(df)) {
      df$median_house_value<-df$median_house_value / median_house_value_scale
  }
  
  return(df)
}

loadAndPreprocess<-function(csvName) {
  return(initialPreprocessing(read.csv(csvName)))
}

all_data=loadAndPreprocess("train.csv")
all_data
```

Es bastante claro que al menos en cierta medida, la proximidad al océano afecta el precio. Esto nos da una pista de que podemos codificar esta variable como ordinal. Movimos esto a nuestra función de pre-procesamiento arriba para aprovecharlo en cualquier dataset.
```{r eval=FALSE}
all_data %>% 
  group_by(ocean_proximity) %>%
  summarize(mean_value = mean(median_house_value)) %>%
  arrange(desc(mean_value))
```


Usamos summary para ver cuáles columnas tienen NAs y verificamos el valor mínimo de cada columna para asegurarnos que no hay NAs disfrazados de 0

```{r fig.width=12}
summary(all_data)
```

Solamente total_bedrooms tiene faltantes y son 144, veamos cuánto es eso en porcentaje.

```{r}
naCount<-sum(is.na(all_data$total_bedrooms))

naCount / length(all_data$total_bedrooms) * 100
```

Prácticamente 1% de datos faltantes. Nos ocuparemos de ellos, pero antes debemos divir los datos en train/test
```{r}
set.seed(279720)
spec = c(train = .80, validate = .20)
#spec = c(train = .7, test = .15, validate = .15)

g = sample(cut(
  seq(nrow(all_data)), 
  nrow(all_data)*cumsum(c(0,spec)),
  labels = names(spec)
))

data = split(all_data, g)
```


```{r}
nasRemoved<-data$train %>% 
  dplyr::select(-c(ocean_proximity, id)) %>%
  filter(!is.na(total_bedrooms))
         
corrplot(cor(nasRemoved), 
         method = "ellipse", 
         type="full",
        addCoef.col = rgb(0,0,0, alpha = 0.6), diag = TRUE, number.cex=0.77, 
        col= colorRampPalette(c("red","white", "green"))(100))
```

Vemos que nuestra variable con NAs (total_bedrooms) tiene correlación casi perfecta con households, por lo que usaremos el valor de esta para obtener datos de imputación. 

```{r}

imp_total_bedrooms<-function(df, traindata=nasRemoved) {
  x<-traindata$households
  y<-traindata$total_bedrooms
  lr<-lm(y ~ x)
  new<-data.frame(x = df$households)
  
  df$total_bedrooms<-as.integer(ifelse(is.na(df$total_bedrooms), 
                                predict(lr, new), 
                                df$total_bedrooms))
  
  return(df)
}

data$train<-imp_total_bedrooms(data$train)
data$validate<-imp_total_bedrooms(data$validate)

print(summary(data$train$total_bedrooms))
print(summary(data$validate$total_bedrooms))

```




```{r fig.height=4, fig.width=12.5}
plot_outliers<-function(df, colname) {
  column<-sym(colname)

  hist<-ggplot(df, aes(x=unlist(!!column)))+
    geom_histogram(color="white", fill="blue")+
    theme_minimal()
  
  box<-ggplot(df, aes(x=unlist(!!column)))+
    geom_boxplot()+
    theme_minimal()
  
  
  qq<-ggplot(df, aes(sample=!!column))+
    stat_qq()+
    stat_qq_line(col="red", lwd=1)
    theme_minimal()

  grid.arrange(hist, box, qq, ncol=3)
}
```


```{r fig.height=4, fig.width=12.5, eval=FALSE}
for (col in names(nasRemoved)) {
  plot_outliers(nasRemoved, col)
}
```



```{r}
# remover outliers detectados a mano
#print(nrow(data$train))
#data$train<-data$train[-match(c(7589, 13996, 8834, 6377, 5815, 7589, 8919, 3137), rownames(data$train)),]
#data$train<-data$train[-c(7589, 13996, 8834, 6377, 5815, 7589, 8919, 3137),]
#print(nrow(data$train))

# nasRemoved<-data$train %>% 
#   select(-c(ocean_proximity, id)) %>%
#   filter(!is.na(total_bedrooms))
# 
# 
# for (col in names(nasRemoved)) {
#   plot_outliers(nasRemoved, col)
# }
# 
```


```{r}
testing_set<-loadAndPreprocess("test.csv")
testing_set<-imp_total_bedrooms(testing_set)
summary(testing_set$total_bedrooms)
```

```{r}
timestamp<-function() {
  my_options <- options(digits.secs = 3)
  timestamp<-strftime(Sys.time(), "%m%d_%H%M%OS")
  options(my_options)  
  return(timestamp)
}

writePredictions<-function(predictions, name, ids=testing_set$id) {
  data<-cbind(id=ids, median_house_value=predictions*median_house_value_scale)
  filename<-paste("predictions/", timestamp(), "_", name, ".csv", sep="")
  write.csv(data, filename, row.names = FALSE, quote=FALSE)
}

```




# Creación y análisis de nuevos features

```{r eval=FALSE}

beds_per_rooms<-data$train$total_bedrooms / data$train$total_rooms
summary(beds_per_rooms)

rooms_per_household<-data$train$total_rooms / data$train$households
summary(rooms_per_household)

income_per_capita<-data$train$median_income/data$train$population
summary(income_per_capita)


income_per_household<-data$train$median_income/data$train$households
summary(income_per_household)

beds_per_capita<-data$train$total_bedrooms / data$train$population
summary(beds_per_capita)

rooms_per_capita<-data$train$total_rooms / data$train$population
summary(rooms_per_capita)


# check this one agian after doing something with the outliers
pop_per_household<-data$train$population/data$train$households
summary(pop_per_household)
  
candidates<-data.frame(beds_per_rooms, rooms_per_household, income_per_capita, income_per_household, beds_per_capita, rooms_per_capita, pop_per_household, data$train$median_house_value)

corrplot(cor(candidates), 
         method = "ellipse", 
         type="full",
        addCoef.col = rgb(0,0,0, alpha = 0.6), diag = TRUE, number.cex=0.77, 
        col= colorRampPalette(c("red","white", "green"))(100))
```


```{r}
extract_xs<-function(df) {
  return(data.frame(x1=df$median_income, x2=df$enc_ocean_proximity, x3=df$total_rooms, x4=df$latitude, x5=df$longitude, x6=df$total_bedrooms, x7=df$housing_median_age))
}

extract_xs_with_extras<-function(df) {
  return(cbind(extract_xs(df), data.frame(w1=df$beds_per_rooms, w2=df$rooms_per_capita, w3=df$rooms_per_household, w4=df$income_per_capita)))
}

addExtraFeats<-function(df) {
  beds_per_rooms<-df$total_bedrooms / df$total_rooms

  rooms_per_household<-df$total_rooms / df$households

  income_per_capita<-df$median_income/df$population
  
  income_per_household<-df$median_income/df$households

  beds_per_capita<-df$total_bedrooms / df$population

  rooms_per_capita<-df$total_rooms / df$population

  # check this one agian after doing something with the outliers
  pop_per_household<-df$population/df$households

  #candidates<-data.frame(beds_per_rooms, rooms_per_household, income_per_capita, income_per_household, beds_per_capita, rooms_per_capita, pop_per_household, df$median_house_value)
  
  return(cbind(df, beds_per_rooms, rooms_per_capita, rooms_per_household, income_per_capita))

}
```

```{r}
data$train<-addExtraFeats(data$train)
```


```{r eval=FALSE}
train_with_extras<-addExtraFeats(data$train)
print(nrow(train_with_extras))


validation_with_extras<-addExtraFeats(data$validate)

y<- train_with_extras$median_house_value
x1<-train_with_extras$median_income
x2<-train_with_extras$enc_ocean_proximity
x3<-train_with_extras$total_rooms
x4<-train_with_extras$latitude
x5<-train_with_extras$longitude
x6<-train_with_extras$total_bedrooms
x7<-train_with_extras$housing_median_age
#x7_binned<-data$train$housing_median_age #FIXME


w1<-train_with_extras$beds_per_rooms
w2<-train_with_extras$rooms_per_capita
w3<-train_with_extras$rooms_per_household
w4<-train_with_extras$income_per_capita

fit8 <- lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + w1, data=train_with_extras)
fit9 <- lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + w1 + w2, data=train_with_extras)
fit10 <- lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + w1 + w2 + w3, data=train_with_extras)
fit11 <- lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + w1 + w2 + w3 +w4, data=train_with_extras)

xs_with_extras<-extract_xs_with_extras(validation_with_extras)

#summary(fit8)
#summary(fit9)
#summary(fit10)
#summary(fit11)

#rmse(predict(fit8,  xs_with_extras), data$validate$median_house_value)*median_house_value_scale
#rmse(predict(fit9,  xs_with_extras), data$validate$median_house_value)*median_house_value_scale
#rmse(predict(fit10, xs_with_extras), data$validate$median_house_value)*median_house_value_scale
#rmse(predict(fit11, xs_with_extras), data$validate$median_house_value)*median_house_value_scale
```


```{r}

# test_with_extras<-addExtraFeats(testing_set)
# xs_test_ex<-extract_xs_with_extras(test_with_extras)
# writePredictions(predict(fit10, xs_test_ex), "fit10")
# writePredictions(predict(fit11, xs_test_ex), "fit11")
```



```{r}
outlier_values <- boxplot.stats(data$train$total_rooms)$out  # outlier values.
boxplot(data$train$total_rooms, main="total_rooms", boxwex=0.1)
print(outlier_values)

outlier_values <- boxplot.stats(data$train$total_bedrooms)$out  # outlier values.
boxplot(data$train$total_bedrooms, main="total_bedrooms", boxwex=0.1)
print(outlier_values)

outlier_values <- boxplot.stats(data$train$population)$out  # outlier values.
boxplot(data$train$population, main="population", boxwex=0.1)
print(outlier_values)

outlier_values <- boxplot.stats(data$train$households)$out  # outlier values.
boxplot(data$train$households, main="households", boxwex=0.1)
print(outlier_values)

outlier_values <- boxplot.stats(data$train$median_income)$out  # outlier values.
boxplot(data$train$median_income, main="median_income", boxwex=0.1)
print(outlier_values)

outlier_values <- boxplot.stats(data$train$median_house_value)$out  # outlier values.
boxplot(data$train$median_house_value, main="median_house_value", boxwex=0.1)
print(outlier_values)
```


```{r fig.height=10, fig.width=10}
cooksd<-cooks.distance(fit11)
plot(cooksd, pch="*", cex=1, main="Influential Obs by Cooks distance")  # plot cook's distance
abline(h = 4*mean(cooksd, na.rm=T), col="red")  # add cutoff line
text(x=1:length(cooksd)+1, y=cooksd, labels=ifelse(cooksd>4*mean(cooksd, na.rm=T),names(cooksd),""), col="red")  # add labels
```


```{r}

distances<-data.frame(d=cooksd[cooksd>4*mean(cooksd, na.rm=T)])
distances<-distances %>% arrange(desc(d))
indices<-as.integer(row.names(distances))

train_with_extras[13996,] #%>% select(total_rooms, total_bedrooms, population, households, median_income)

```

```{r}
distances<-data.frame(d=cooksd[cooksd>4*mean(cooksd, na.rm=T)])
distances<-distances %>% arrange(desc(d))
indices<-as.integer(row.names(distances))
class(indices)

train_with_extras[match(indices, rownames(train_with_extras)),]
# 7589, 13996, 8834, 6377, 5815, 7589, 8919, 3137
```




```{r}
car::outlierTest(fit11)
```
```{r fig.height=10, fig.width=10}


train_with_extras<-train_with_extras[-match(indices[1:20], rownames(train_with_extras)),]

y<- train_with_extras$median_house_value
x1<-train_with_extras$median_income
x2<-train_with_extras$enc_ocean_proximity
x3<-train_with_extras$total_rooms
x4<-train_with_extras$latitude
x5<-train_with_extras$longitude
x6<-train_with_extras$total_bedrooms
x7<-train_with_extras$housing_median_age
#x7_binned<-data$train$housing_median_age #FIXME


w1<-train_with_extras$beds_per_rooms
w2<-train_with_extras$rooms_per_capita
w3<-train_with_extras$rooms_per_household
w4<-train_with_extras$income_per_capita



fit11_ <- lm(y ~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + w1 + w2 + w3 +w4, data=train_with_extras)

cooksd<-cooks.distance(fit11_)
plot(cooksd, pch="*", cex=1, main="Influential Obs by Cooks distance")  # plot cook's distance
abline(h = 4*mean(cooksd, na.rm=T), col="red")  # add cutoff line
text(x=1:length(cooksd)+1, y=cooksd, labels=ifelse(cooksd>4*mean(cooksd, na.rm=T),names(cooksd),""), col="red")  # add labels

car::outlierTest(fit11_)

```
```{r}

rmse(predict(fit11, xs_with_extras), data$validate$median_house_value)*median_house_value_scale
rmse(predict(fit11_, xs_with_extras), data$validate$median_house_value)*median_house_value_scale

print(nrow(train_with_extras))
```

```{r}
test_with_extras<-addExtraFeats(testing_set)
 xs_test_ex<-extract_xs_with_extras(test_with_extras)
 writePredictions(predict(fit11_, xs_test_ex), "fit11_OL")
# writePredictions(predict(fit11, xs_test_ex), "fit11")
```


```{r}
folds <- cvFolds(nrow(train_with_extras), K = 5, R = 10)
repCV(fit11, cost = rmspe, folds = folds)
repCV(fit11_, cost = rmspe, folds = folds)



```
 
